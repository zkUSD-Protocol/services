name: Build and Deploy Proof Generator

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write    # requesting the OIDC JWT token

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      # Outputs for the second job:
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}
      docker_tag: ${{ steps.set_docker_tag.outputs.tag }}

      hetzner_host: ${{ steps.parse-outputs.outputs.hetzner_host }}
      hetzner_username: ${{ steps.parse-outputs.outputs.hetzner_username }}
      hetzner_ssh_key: ${{ steps.fetch-secrets.outputs.hetzner_ssh_key }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: arn:aws:iam::565802942559:role/zkusd-services-github-actions-role
          aws-region: eu-central-1

      - name: Download Terraform outputs
        run: aws s3 cp s3://zkusd-terraform-outputs/terraform-outputs.json terraform-outputs.json

      - name: Debug TF file
        run: |
          echo "==== Dumping terraform-outputs.json ===="
          cat terraform-outputs.json
          echo "==== Testing with jq ===="
          echo "proof_generator_ip:"
          jq -r '.proof_generator_ip.value' terraform-outputs.json
          echo "proof_generator_username:"
          jq -r '.proof_generator_username.value' terraform-outputs.json

      - name: Parse Terraform outputs
        id: parse-outputs
        run: |
          HETZNER_HOST=$(jq -r '.proof_generator_ip.value' terraform-outputs.json)
          HETZNER_USERNAME=$(jq -r '.proof_generator_username.value' terraform-outputs.json)

          echo "DEBUG: HETZNER_HOST=${HETZNER_HOST}"
          echo "DEBUG: HETZNER_USERNAME=${HETZNER_USERNAME}"

          # Mask them (so if they're not empty, they'd be redacted in logs)
          echo "::add-mask::$HETZNER_HOST"
          echo "::add-mask::$HETZNER_USERNAME"

          # Expose as step outputs
          echo "hetzner_host=$HETZNER_HOST" >> $GITHUB_OUTPUT
          echo "hetzner_username=$HETZNER_USERNAME" >> $GITHUB_OUTPUT

      - name: Fetch secret values
        id: fetch-secrets
        run: |
          # SSH Key for Hetzner
          HETZNER_SSH_KEY=$(aws secretsmanager get-secret-value \
            --secret-id zkusd/dev/proof-generator/ssh/public-key \
            --query SecretString --output text)

          echo "::add-mask::$HETZNER_SSH_KEY"
          echo "hetzner_ssh_key=$HETZNER_SSH_KEY" >> $GITHUB_OUTPUT

          # Mongo URI
          MONGO_URI=$(aws secretsmanager get-secret-value --secret-id zkusd/dev/mongo-uri --query SecretString --output text)
          echo "::add-mask::$MONGO_URI"
          echo "MONGO_URI=$MONGO_URI" >> $GITHUB_ENV

          # Oracles 1 to 3
          for i in 1 2 3; do
            PRIVATE_KEY=$(aws secretsmanager get-secret-value --secret-id zkusd/dev/oracle-${i}/secret-key --query SecretString --output text)
            PUBLIC_KEY=$(aws secretsmanager get-secret-value --secret-id zkusd/dev/oracle-${i}/public-key --query SecretString --output text)

            echo "::add-mask::$PRIVATE_KEY"
            echo "::add-mask::$PUBLIC_KEY"

            echo "DEVNET_ORACLE_${i}_PRIVATE_KEY=$PRIVATE_KEY" >> $GITHUB_ENV
            echo "DEVNET_ORACLE_${i}_PUBLIC_KEY=$PUBLIC_KEY" >> $GITHUB_ENV
          done

          # Dummy oracle keys
          DUMMY_PRIVATE_KEY=$(aws secretsmanager get-secret-value --secret-id zkusd/dev/oracle-dummy/secret-key --query SecretString --output text)
          DUMMY_PUBLIC_KEY=$(aws secretsmanager get-secret-value --secret-id zkusd/dev/oracle-dummy/public-key --query SecretString --output text)

          echo "::add-mask::$DUMMY_PRIVATE_KEY"
          echo "::add-mask::$DUMMY_PUBLIC_KEY"

          echo "DEVNET_ORACLE_DUMMY_PRIVATE_KEY=$DUMMY_PRIVATE_KEY" >> $GITHUB_ENV
          echo "DEVNET_ORACLE_DUMMY_PUBLIC_KEY=$DUMMY_PUBLIC_KEY" >> $GITHUB_ENV

      - name: Set Docker tag
        id: set_docker_tag
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          echo "tag=$SHORT_SHA" >> $GITHUB_OUTPUT

      # 7) LOGIN TO ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
        with:
          mask-password: true

      # 8) BUILD AND PUSH DOCKER IMAGE
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/zkusd-containers:latest
            ${{ steps.login-ecr.outputs.registry }}/zkusd-containers:${{ steps.set_docker_tag.outputs.tag }}
          build-args: |
            NODE_ENV=production
            NETWORK=devnet
            BLOCKCHECK_INTERVAL=10
            MONGO_URI=${{ env.MONGO_URI }}
            NUMBER_OF_ORACLES=3
            DEVNET_ORACLE_1_PRIVATE_KEY=${{ env.DEVNET_ORACLE_1_PRIVATE_KEY }}
            DEVNET_ORACLE_1_PUBLIC_KEY=${{ env.DEVNET_ORACLE_1_PUBLIC_KEY }}
            DEVNET_ORACLE_2_PRIVATE_KEY=${{ env.DEVNET_ORACLE_2_PRIVATE_KEY }}
            DEVNET_ORACLE_2_PUBLIC_KEY=${{ env.DEVNET_ORACLE_2_PUBLIC_KEY }}
            DEVNET_ORACLE_3_PRIVATE_KEY=${{ env.DEVNET_ORACLE_3_PRIVATE_KEY }}
            DEVNET_ORACLE_3_PUBLIC_KEY=${{ env.DEVNET_ORACLE_3_PUBLIC_KEY }}
            DEVNET_ORACLE_DUMMY_PRIVATE_KEY=${{ env.DEVNET_ORACLE_DUMMY_PRIVATE_KEY }}
            DEVNET_ORACLE_DUMMY_PUBLIC_KEY=${{ env.DEVNET_ORACLE_DUMMY_PUBLIC_KEY }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: arn:aws:iam::565802942559:role/zkusd-services-github-actions-role
          aws-region: eu-central-1

      - name: Debug outputs from build-and-push (for verification, remove if not needed)
        run: |
          echo "HETZNER_HOST=${{ needs.build-and-push.outputs.hetzner_host }}"
          echo "HETZNER_USERNAME=${{ needs.build-and-push.outputs.hetzner_username }}"
          echo "HETZNER_SSH_KEY length=${{ needs.build-and-push.outputs.hetzner_ssh_key != '' && 'VALID' || 'EMPTY' }}"

      - name: Deploy to Hetzner
        uses: appleboy/ssh-action@master
        with:
          host: ${{ needs.build-and-push.outputs.hetzner_host }}
          username: ${{ needs.build-and-push.outputs.hetzner_username }}
          key: ${{ needs.build-and-push.outputs.hetzner_ssh_key }}
          envs: AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_SESSION_TOKEN
          script: |
            set -e

            # 1) Install AWS CLI (v2) if not present
            if ! command -v aws &> /dev/null; then
              echo "Installing AWS CLI..."
              apt-get update && apt-get install -y unzip curl
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip awscliv2.zip
              ./aws/install
              export PATH=$PATH:/usr/local/bin
            fi

            # 2) Verify AWS CLI works
            aws --version

            # 3) ECR login
            ECR_REGISTRY="${{ needs.build-and-push.outputs.ecr_registry }}"
            echo "Logging into ECR registry: $ECR_REGISTRY"

            INPUT_HOST="${{ needs.build-and-push.outputs.hetzner_host }}"
            INPUT_USERNAME="${{ needs.build-and-push.outputs.hetzner_username }}"
            echo "HOST $HOST"
            echo "USERNAMe $USERNAME"

            aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin $ECR_REGISTRY

            # 4) Pull Docker image from ECR
            ECR_IMAGE="$ECR_REGISTRY/zkusd-containers:${{ needs.build-and-push.outputs.docker_tag }}"
            echo "Pulling Docker image: $ECR_IMAGE"

            if ! docker pull "$ECR_IMAGE"; then
              echo "Failed to pull Docker image"
              exit 1
            fi

            # 5) Stop and remove the existing container
            echo "Stopping and removing old container..."
            docker stop zkusd-services-container || true
            docker rm zkusd-services-container || true

            # 6) Run the new container
            echo "Starting new container from $ECR_IMAGE"
            if ! docker run -d \
              --name zkusd-services-container \
              --restart unless-stopped \
              "$ECR_IMAGE"; then
              echo "Failed to start container"
              exit 1
            fi

            # 7) Verify container is running
            echo "Verifying container is running..."
            if ! docker ps | grep -q zkusd-services-container; then
              echo "Container is not running after deployment"
              exit 1
            fi

            echo "âœ… Deployment successful!"
